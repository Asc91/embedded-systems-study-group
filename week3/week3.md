# Embedded Systems Study Group

- [Memory Allocation in C](#memory-allocation-in-c)
    - [Text Segment](#text-segment)
    - [Stack](#stack)
    - [Heap](#heap)

## Memory Allocation in C
When any program is loaded into the memory, it is organised into three parts called segments, which are:

- Text segment (the code segment)
- Stack segment
- Heap segment

### Text Segment
The text segment is where the compiled code of the program itself resides. This is the machine language representation of the program steps to be carried out, including all functions making up the program, both user and system defined. So, in general, an executable program generated by a compiler (like GCC) will have memory organisation. This part also contains the global, constant and also uninitialized variables.

### Stack
The stack is used to store variables used on the inside of a function (including the main() function). It’s a LIFO, “Last-In,-First-Out”, structure. Every time a function declares a new variable it is “pushed” onto the stack. Then when a function finishes running, all the variables associated with that function on the stack are deleted, and the memory they use is freed up. This leads to the “local” scope of function variables. The stack is a special region of memory, and automatically managed by the CPU – so you don’t have to allocate or deallocate memory.

TL;DR Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and its allocation is dealt with when the program is compiled

```c
#include<stdio.h>

void main()
{
    int a = 0;
    int b = 10;
    char c = 2;
    double d = 0.40;
    float e = 10000;

    printf("%p   %ld\n", &a, sizeof(a));
    printf("%p   %ld\n", &b, sizeof(b));
    printf("%p   %ld\n", &c, sizeof(c));
    printf("%p   %ld\n", &d, sizeof(d));
    printf("%p   %ld\n", &e, sizeof(e));
}

```
<p align="left">
        <img width="780" height="150" src="../assets/week3/stack_op.png">
    </p>
You can observe that the stack grows up. 

If a program tries to put too much information on the stack, stack overflow will occur. Stack overflow happens when all the memory in the stack has been allocated, and further allocations begin overflowing into other sections of memory

### Heap

Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time.

The heap is the diametrical opposite of the stack. The heap is a large pool of memory that can be used dynamically – it is also known as the “free store”. This is memory that is not automatically managed – you have to explicitly allocate (using functions such as malloc), and deallocate (e.g. free) the memory. Failure to free the memory when you are finished with it will result in what is known as a memory leak – memory that is still “being used”, and not available to other processes. Unlike the stack, there are generally no restrictions on the size of the heap (or the variables it creates), other than the physical size of memory in the machine. Variables created on the heap are accessible anywhere in the program.
Oh, and heap memory requires you to use pointers.

```c
#include <stdio.h>
#include <stdlib.h>

int x;          

int main(void) 
{
    int y;   
    char *str; 

    y = 4;
    printf("stack memory: %d\n", y);

    str = (char*)malloc(100*sizeof(char)); 
    str[0] = 'm';
    printf("heap memory: %c\n", str[0]); 
    free(str);         
    return 0;
}
```
<p align="center">
        <img width="480" height="550" src="../assets/week3/memory.jpg">
</p>

The variable `x` is static storage, because of its global nature. Both `y` and `str` are dynamic stack storage which is deallocated when the program ends. The function `malloc()` is used to allocate 100 pieces of of dynamic heap storage, each the size of `char`, to `str`. `str` is in the stack it only points to a memory location in heap. Conversely, the function `free()`, deallocates the memory associated with `str`. 



GENERAL POINTS  
You can use the stack if you know exactly how much data you need to allocate before compile time and it is not too big. You can use heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.
